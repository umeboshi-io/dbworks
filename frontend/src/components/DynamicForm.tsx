import { useState, type FormEvent } from 'react';
import type { TableSchema, ColumnInfo, RowData } from '../types';
import './DynamicForm.css';

interface DynamicFormProps {
  schema: TableSchema;
  initialData: RowData | null;
  onSubmit: (data: RowData) => Promise<void>;
  onCancel: () => void;
}

/**
 * Convert a DB value to the format expected by HTML input elements.
 * - datetime-local: "YYYY-MM-DDTHH:mm:ss"
 * - date: "YYYY-MM-DD"
 */
function formatValueForInput(value: unknown, dataType: string): unknown {
  if (value == null || value === '') return '';

  const inputType = getInputType(dataType);

  if (inputType === 'datetime-local') {
    try {
      const d = new Date(value as string);
      if (isNaN(d.getTime())) return String(value);
      const pad = (n: number) => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    } catch {
      return String(value);
    }
  }

  if (inputType === 'date') {
    try {
      const d = new Date(value as string);
      if (isNaN(d.getTime())) return String(value);
      const pad = (n: number) => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
    } catch {
      return String(value);
    }
  }

  return value;
}

function getInputType(dataType: string): string {
  switch (dataType) {
    case 'integer':
    case 'bigint':
    case 'smallint':
    case 'numeric':
    case 'real':
    case 'double precision':
      return 'number';
    case 'boolean':
      return 'checkbox';
    case 'date':
      return 'date';
    case 'timestamp without time zone':
    case 'timestamp with time zone':
      return 'datetime-local';
    default:
      return 'text';
  }
}

function DynamicForm({ schema, initialData, onSubmit, onCancel }: DynamicFormProps) {
  const [formData, setFormData] = useState<RowData>(() => {
    if (initialData) {
      const converted: RowData = {};
      for (const [key, val] of Object.entries(initialData)) {
        const col = schema.columns.find((c) => c.column_name === key);
        if (col) {
          converted[key] = formatValueForInput(val, col.data_type);
        } else {
          converted[key] = val;
        }
      }
      return converted;
    }
    const initial: RowData = {};
    schema.columns.forEach((col) => {
      if (col.column_default && !initialData) return;
      initial[col.column_name] = '';
    });
    return initial;
  });
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const handleChange = (colName: string, value: unknown) => {
    setFormData((prev) => ({ ...prev, [colName]: value }));
  };

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    try {
      const cleaned: RowData = {};
      schema.columns.forEach((col) => {
        const val = formData[col.column_name];
        if (val === undefined) return;
        if (!initialData && col.column_default && (val === '' || val === null)) return;
        if (val === '' && col.is_nullable) {
          cleaned[col.column_name] = null;
          return;
        }
        if (val === '') return;
        cleaned[col.column_name] = val;
      });
      await onSubmit(cleaned);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  };

  const isAutoGenerated = (col: ColumnInfo): boolean => {
    return !!(
      col.column_default &&
      (col.column_default.includes('nextval') ||
        col.column_default.includes('CURRENT_TIMESTAMP') ||
        col.column_default.includes('now()'))
    );
  };

  const editableColumns = schema.columns.filter((col) => {
    if (!initialData && isAutoGenerated(col)) return false;
    return true;
  });

  return (
    <form className="dynamic-form" onSubmit={handleSubmit}>
      {error && <div className="alert alert-error">{error}</div>}
      <div className="form-body">
        {editableColumns.map((col) => {
          const inputType = getInputType(col.data_type);
          const isDisabled = !!(initialData && col.is_primary_key);
          const value = formData[col.column_name] ?? '';

          return (
            <div key={col.column_name} className="form-group">
              <label htmlFor={`field-${col.column_name}`}>
                <span className="label-name">{col.column_name}</span>
                <span className="label-meta">
                  <span className="label-type">{col.data_type}</span>
                  {!col.is_nullable && <span className="required">*</span>}
                  {col.is_primary_key && <span className="pk-tag">PK</span>}
                </span>
              </label>
              {inputType === 'checkbox' ? (
                <label className="checkbox-wrapper">
                  <input
                    id={`field-${col.column_name}`}
                    type="checkbox"
                    checked={value === true || value === 'true'}
                    onChange={(e) => handleChange(col.column_name, e.target.checked)}
                    disabled={isDisabled}
                  />
                  <span className="checkbox-label">
                    {value === true || value === 'true' ? 'true' : 'false'}
                  </span>
                </label>
              ) : col.data_type === 'text' ? (
                <textarea
                  id={`field-${col.column_name}`}
                  value={String(value)}
                  onChange={(e) => handleChange(col.column_name, e.target.value)}
                  disabled={isDisabled}
                  rows={3}
                />
              ) : (
                <input
                  id={`field-${col.column_name}`}
                  type={inputType}
                  value={String(value)}
                  onChange={(e) => handleChange(col.column_name, e.target.value)}
                  disabled={isDisabled}
                  step={inputType === 'number' ? 'any' : inputType === 'datetime-local' ? '1' : undefined}
                  maxLength={col.max_length || undefined}
                />
              )}
            </div>
          );
        })}
      </div>
      <div className="form-actions">
        <button type="button" className="btn btn-ghost" onClick={onCancel}>
          Cancel
        </button>
        <button type="submit" className="btn btn-primary" disabled={loading}>
          {loading ? <span className="loading-spinner" /> : initialData ? 'Update' : 'Create'}
        </button>
      </div>
    </form>
  );
}

export default DynamicForm;
